{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "pmlc2ha8fopsx1xc",
				"title": "File Export",
				"enabled": true,
				"type": "action",
				"command": "node",
				"script": "#!/usr/bin/env node\n\n/**\n * xyOps File Export Action Plugin\n * \n * Exports job input data to CSV, HTML, or JSON file format.\n * Supports optional timestamp and unique identifier in filename.\n * Cross-platform compatible (Linux, Windows, macOS).\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Optional dependencies (loaded on demand)\nlet exceljs = null;\nlet PDFDocument = null;\n\n// Get plugin directory for npm install\nconst pluginDir = __dirname;\n\n// Try to install a package\nfunction tryInstallPackage(packageName) {\n    try {\n        console.error(`File Export: Installing ${packageName}...`);\n        execSync(`npm install ${packageName} --save`, {\n            cwd: pluginDir,\n            stdio: ['pipe', 'pipe', 'pipe'],\n            timeout: 120000 // 2 minute timeout\n        });\n        console.error(`File Export: ${packageName} installed successfully`);\n        return true;\n    } catch (e) {\n        console.error(`File Export: Failed to install ${packageName}: ${e.message}`);\n        return false;\n    }\n}\n\n// Try to load optional dependencies (auto-install if missing)\nfunction loadExcelJS() {\n    if (exceljs === null) {\n        try {\n            exceljs = require('exceljs');\n        } catch (e) {\n            // Try to auto-install\n            if (tryInstallPackage('exceljs')) {\n                try {\n                    exceljs = require('exceljs');\n                } catch (e2) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction loadPDFKit() {\n    if (PDFDocument === null) {\n        try {\n            PDFDocument = require('pdfkit');\n        } catch (e) {\n            // Try to auto-install\n            if (tryInstallPackage('pdfkit')) {\n                try {\n                    PDFDocument = require('pdfkit');\n                } catch (e2) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Read JSON from STDIN\nasync function readStdin() {\n    const chunks = [];\n    for await (const chunk of process.stdin) {\n        chunks.push(chunk);\n    }\n    return JSON.parse(chunks.join(''));\n}\n\n// Generate 8-character unique ID\nfunction generateUID() {\n    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n    let uid = '';\n    for (let i = 0; i < 8; i++) {\n        uid += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return uid;\n}\n\n// Generate timestamp in YYYYMMDD_HHmmss format\nfunction generateTimestamp() {\n    const now = new Date();\n    const year = now.getFullYear();\n    const month = String(now.getMonth() + 1).padStart(2, '0');\n    const day = String(now.getDate()).padStart(2, '0');\n    const hours = String(now.getHours()).padStart(2, '0');\n    const minutes = String(now.getMinutes()).padStart(2, '0');\n    const seconds = String(now.getSeconds()).padStart(2, '0');\n    return `${year}${month}${day}_${hours}${minutes}${seconds}`;\n}\n\n// Flatten nested object into dot-notation keys\nfunction flattenObject(obj, prefix = '', result = {}) {\n    if (obj === null || obj === undefined) {\n        result[prefix] = '';\n        return result;\n    }\n    \n    if (typeof obj !== 'object') {\n        result[prefix] = obj;\n        return result;\n    }\n    \n    if (Array.isArray(obj)) {\n        if (obj.length === 0) {\n            result[prefix] = '';\n        } else {\n            // Check if array contains objects or primitives\n            const hasObjects = obj.some(item => typeof item === 'object' && item !== null);\n            if (hasObjects) {\n                obj.forEach((item, index) => {\n                    flattenObject(item, prefix ? `${prefix}[${index}]` : `[${index}]`, result);\n                });\n            } else {\n                result[prefix] = obj.join(', ');\n            }\n        }\n        return result;\n    }\n    \n    for (const key of Object.keys(obj)) {\n        const newKey = prefix ? `${prefix}.${key}` : key;\n        flattenObject(obj[key], newKey, result);\n    }\n    \n    return result;\n}\n\n// Convert data to CSV format\nfunction toCSV(data) {\n    if (!data || typeof data !== 'object') {\n        return 'No data';\n    }\n    \n    // Handle raw stdout output (single 'output' key with multiline string)\n    // Convert each line to a row for better CSV usability\n    if (!Array.isArray(data) && Object.keys(data).length === 1 && \n        data.output && typeof data.output === 'string') {\n        const lines = data.output.trim().split('\\n');\n        const csvRows = ['line_number,output'];\n        lines.forEach((line, index) => {\n            csvRows.push(`${index + 1},${escapeCSV(line)}`);\n        });\n        return csvRows.join('\\n');\n    }\n    \n    // Handle array of objects (most common case)\n    if (Array.isArray(data)) {\n        if (data.length === 0) {\n            return 'No data';\n        }\n        \n        // Flatten each row\n        const flattenedRows = data.map(row => flattenObject(row));\n        \n        // Collect all unique headers\n        const headersSet = new Set();\n        flattenedRows.forEach(row => {\n            Object.keys(row).forEach(key => headersSet.add(key));\n        });\n        const headers = Array.from(headersSet);\n        \n        // Build CSV\n        const csvRows = [];\n        csvRows.push(headers.map(escapeCSV).join(','));\n        \n        flattenedRows.forEach(row => {\n            const values = headers.map(header => escapeCSV(row[header] ?? ''));\n            csvRows.push(values.join(','));\n        });\n        \n        return csvRows.join('\\n');\n    }\n    \n    // Handle single object\n    const flattened = flattenObject(data);\n    const headers = Object.keys(flattened);\n    const values = Object.values(flattened);\n    \n    const csvRows = [];\n    csvRows.push(headers.map(escapeCSV).join(','));\n    csvRows.push(values.map(escapeCSV).join(','));\n    \n    return csvRows.join('\\n');\n}\n\n// Escape CSV value\nfunction escapeCSV(value) {\n    if (value === null || value === undefined) {\n        return '';\n    }\n    const str = String(value);\n    if (str.includes(',') || str.includes('\"') || str.includes('\\n') || str.includes('\\r')) {\n        return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n}\n\n// Convert data to HTML format\nfunction toHTML(data, title = 'Exported Data') {\n    const escapeHTML = (str) => {\n        if (str === null || str === undefined) return '';\n        return String(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n    };\n    \n    let tableContent = '';\n    let isRawOutput = false;\n    \n    // Check if this is raw stdout output (single 'output' key with multiline string)\n    if (data && typeof data === 'object' && !Array.isArray(data) && \n        Object.keys(data).length === 1 && data.output && typeof data.output === 'string') {\n        isRawOutput = true;\n    }\n    \n    if (isRawOutput) {\n        // Display raw output as preformatted text\n        tableContent = `<tbody><tr><td><pre>${escapeHTML(data.output)}</pre></td></tr></tbody>`;\n    } else if (Array.isArray(data) && data.length > 0) {\n        // Flatten each row for arrays\n        const flattenedRows = data.map(row => flattenObject(row));\n        \n        // Collect all unique headers\n        const headersSet = new Set();\n        flattenedRows.forEach(row => {\n            Object.keys(row).forEach(key => headersSet.add(key));\n        });\n        const headers = Array.from(headersSet);\n        \n        // Build table header\n        tableContent += '<thead><tr>';\n        headers.forEach(header => {\n            tableContent += `<th>${escapeHTML(header)}</th>`;\n        });\n        tableContent += '</tr></thead>';\n        \n        // Build table body\n        tableContent += '<tbody>';\n        flattenedRows.forEach(row => {\n            tableContent += '<tr>';\n            headers.forEach(header => {\n                tableContent += `<td>${escapeHTML(row[header] ?? '')}</td>`;\n            });\n            tableContent += '</tr>';\n        });\n        tableContent += '</tbody>';\n    } else if (data && typeof data === 'object') {\n        // Single object - display as key-value pairs\n        const flattened = flattenObject(data);\n        \n        tableContent += '<thead><tr><th>Key</th><th>Value</th></tr></thead>';\n        tableContent += '<tbody>';\n        for (const [key, value] of Object.entries(flattened)) {\n            tableContent += `<tr><td>${escapeHTML(key)}</td><td>${escapeHTML(value)}</td></tr>`;\n        }\n        tableContent += '</tbody>';\n    } else {\n        tableContent = '<tbody><tr><td>No data available</td></tr></tbody>';\n    }\n    \n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${escapeHTML(title)}</title>\n    <style>\n        * {\n            box-sizing: border-box;\n        }\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n        }\n        h1 {\n            color: #2c3e50;\n            margin-bottom: 20px;\n            font-size: 24px;\n        }\n        .meta {\n            color: #666;\n            font-size: 14px;\n            margin-bottom: 20px;\n        }\n        .container {\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            overflow: hidden;\n        }\n        table {\n            width: 100%;\n            border-collapse: collapse;\n        }\n        th, td {\n            padding: 12px 15px;\n            text-align: left;\n            border-bottom: 1px solid #e0e0e0;\n        }\n        th {\n            background-color: #3498db;\n            color: white;\n            font-weight: 600;\n            text-transform: uppercase;\n            font-size: 12px;\n            letter-spacing: 0.5px;\n        }\n        tr:hover {\n            background-color: #f8f9fa;\n        }\n        tr:last-child td {\n            border-bottom: none;\n        }\n        td {\n            font-size: 14px;\n        }\n        .empty {\n            padding: 40px;\n            text-align: center;\n            color: #999;\n        }\n        pre {\n            margin: 0;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 4px;\n            overflow-x: auto;\n            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\n            font-size: 13px;\n            line-height: 1.5;\n            white-space: pre-wrap;\n            word-wrap: break-word;\n        }\n    </style>\n</head>\n<body>\n    <h1>${escapeHTML(title)}</h1>\n    <p class=\"meta\">Generated: ${new Date().toISOString()}</p>\n    <div class=\"container\">\n        <table>\n            ${tableContent}\n        </table>\n    </div>\n</body>\n</html>`;\n}\n\n// Convert data to pretty JSON\nfunction toJSON(data) {\n    return JSON.stringify(data, null, 2);\n}\n\n// Convert data to XML format\nfunction toXML(data, rootName = 'data') {\n    const escapeXML = (str) => {\n        if (str === null || str === undefined) return '';\n        return String(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    };\n    \n    const toXMLNode = (obj, nodeName, indent = '  ') => {\n        if (obj === null || obj === undefined) {\n            return `${indent}<${nodeName}/>`;\n        }\n        \n        if (typeof obj !== 'object') {\n            return `${indent}<${nodeName}>${escapeXML(obj)}</${nodeName}>`;\n        }\n        \n        if (Array.isArray(obj)) {\n            if (obj.length === 0) {\n                return `${indent}<${nodeName}/>`;\n            }\n            // For arrays, use singular form for items\n            const itemName = nodeName.endsWith('s') ? nodeName.slice(0, -1) : 'item';\n            const items = obj.map(item => toXMLNode(item, itemName, indent + '  ')).join('\\n');\n            return `${indent}<${nodeName}>\\n${items}\\n${indent}</${nodeName}>`;\n        }\n        \n        // Object\n        const entries = Object.entries(obj);\n        if (entries.length === 0) {\n            return `${indent}<${nodeName}/>`;\n        }\n        \n        const children = entries.map(([key, value]) => {\n            // Sanitize key for XML (remove invalid characters, replace spaces)\n            const xmlKey = key.replace(/[^a-zA-Z0-9_-]/g, '_').replace(/^[0-9]/, '_$&');\n            return toXMLNode(value, xmlKey, indent + '  ');\n        }).join('\\n');\n        \n        return `${indent}<${nodeName}>\\n${children}\\n${indent}</${nodeName}>`;\n    };\n    \n    let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    \n    if (Array.isArray(data)) {\n        xml += `<${rootName}>\\n`;\n        const itemName = rootName === 'data' ? 'item' : (rootName.endsWith('s') ? rootName.slice(0, -1) : 'item');\n        data.forEach(item => {\n            xml += toXMLNode(item, itemName, '  ') + '\\n';\n        });\n        xml += `</${rootName}>`;\n    } else {\n        xml += toXMLNode(data, rootName, '').trimStart();\n    }\n    \n    return xml;\n}\n\n// Convert data to YAML format\nfunction toYAML(data, indent = 0) {\n    const spaces = '  '.repeat(indent);\n    \n    if (data === null || data === undefined) {\n        return 'null';\n    }\n    \n    if (typeof data === 'boolean') {\n        return data ? 'true' : 'false';\n    }\n    \n    if (typeof data === 'number') {\n        return String(data);\n    }\n    \n    if (typeof data === 'string') {\n        // Check if string needs quoting\n        if (data === '' || \n            data.includes(':') || \n            data.includes('#') || \n            data.includes('\\n') ||\n            data.startsWith(' ') ||\n            data.endsWith(' ') ||\n            /^[\\[\\]{}>&*!|>'\"%@`]/.test(data) ||\n            ['true', 'false', 'null', 'yes', 'no', 'on', 'off'].includes(data.toLowerCase())) {\n            // Use quoted string\n            return '\"' + data.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"';\n        }\n        return data;\n    }\n    \n    if (Array.isArray(data)) {\n        if (data.length === 0) {\n            return '[]';\n        }\n        let yaml = '';\n        data.forEach((item, index) => {\n            const itemYaml = toYAML(item, indent + 1);\n            if (typeof item === 'object' && item !== null && !Array.isArray(item)) {\n                yaml += `${spaces}- ${itemYaml.trimStart()}`;\n            } else {\n                yaml += `${spaces}- ${itemYaml}`;\n            }\n            if (index < data.length - 1) yaml += '\\n';\n        });\n        return yaml;\n    }\n    \n    if (typeof data === 'object') {\n        const entries = Object.entries(data);\n        if (entries.length === 0) {\n            return '{}';\n        }\n        let yaml = '';\n        entries.forEach(([key, value], index) => {\n            // Escape key if needed\n            let yamlKey = key;\n            if (key.includes(':') || key.includes('#') || key.includes(' ')) {\n                yamlKey = '\"' + key.replace(/\"/g, '\\\\\"') + '\"';\n            }\n            \n            const valueYaml = toYAML(value, indent + 1);\n            \n            if (typeof value === 'object' && value !== null && \n                ((Array.isArray(value) && value.length > 0) || \n                 (!Array.isArray(value) && Object.keys(value).length > 0))) {\n                yaml += `${spaces}${yamlKey}:\\n${valueYaml}`;\n            } else {\n                yaml += `${spaces}${yamlKey}: ${valueYaml}`;\n            }\n            if (index < entries.length - 1) yaml += '\\n';\n        });\n        return yaml;\n    }\n    \n    return String(data);\n}\n\n// Convert data to plain text table format\nfunction toTXT(data, title = 'Exported Data') {\n    let txt = '';\n    txt += '=' .repeat(60) + '\\n';\n    txt += `  ${title}\\n`;\n    txt += `  Generated: ${new Date().toISOString()}\\n`;\n    txt += '='.repeat(60) + '\\n\\n';\n    \n    // Handle raw stdout output\n    if (data && typeof data === 'object' && !Array.isArray(data) &&\n        Object.keys(data).length === 1 && data.output && typeof data.output === 'string') {\n        txt += data.output + '\\n';\n        return txt;\n    }\n    \n    if (Array.isArray(data) && data.length > 0) {\n        // Flatten for table display\n        const flattenedRows = data.map(row => flattenObject(row));\n        \n        // Collect all headers\n        const headersSet = new Set();\n        flattenedRows.forEach(row => {\n            Object.keys(row).forEach(key => headersSet.add(key));\n        });\n        const headers = Array.from(headersSet);\n        \n        // Calculate column widths\n        const colWidths = headers.map(h => {\n            const maxDataWidth = Math.max(...flattenedRows.map(row => String(row[h] ?? '').length));\n            return Math.max(h.length, maxDataWidth, 4);\n        });\n        \n        // Header row\n        txt += headers.map((h, i) => h.padEnd(colWidths[i])).join(' | ') + '\\n';\n        txt += colWidths.map(w => '-'.repeat(w)).join('-+-') + '\\n';\n        \n        // Data rows\n        flattenedRows.forEach(row => {\n            txt += headers.map((h, i) => String(row[h] ?? '').padEnd(colWidths[i])).join(' | ') + '\\n';\n        });\n    } else if (data && typeof data === 'object') {\n        const flattened = flattenObject(data);\n        const maxKeyLen = Math.max(...Object.keys(flattened).map(k => k.length));\n        \n        for (const [key, value] of Object.entries(flattened)) {\n            txt += `${key.padEnd(maxKeyLen)} : ${value}\\n`;\n        }\n    } else {\n        txt += 'No data available\\n';\n    }\n    \n    txt += '\\n' + '='.repeat(60) + '\\n';\n    return txt;\n}\n\n// Convert data to Excel format (requires exceljs)\nasync function toExcel(data, title = 'Exported Data') {\n    if (!loadExcelJS()) {\n        throw new Error('Excel export requires exceljs. Run: npm install exceljs');\n    }\n    \n    const workbook = new exceljs.Workbook();\n    workbook.creator = 'xyOps File Export';\n    workbook.created = new Date();\n    \n    const worksheet = workbook.addWorksheet(title.substring(0, 31)); // Excel sheet name max 31 chars\n    \n    if (Array.isArray(data) && data.length > 0) {\n        // Flatten for table display\n        const flattenedRows = data.map(row => flattenObject(row));\n        \n        // Collect all headers\n        const headersSet = new Set();\n        flattenedRows.forEach(row => {\n            Object.keys(row).forEach(key => headersSet.add(key));\n        });\n        const headers = Array.from(headersSet);\n        \n        // Add header row\n        worksheet.addRow(headers);\n        \n        // Style header row\n        const headerRow = worksheet.getRow(1);\n        headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };\n        headerRow.fill = {\n            type: 'pattern',\n            pattern: 'solid',\n            fgColor: { argb: 'FF3498DB' }\n        };\n        \n        // Add data rows\n        flattenedRows.forEach(row => {\n            const values = headers.map(h => row[h] ?? '');\n            worksheet.addRow(values);\n        });\n        \n        // Auto-fit columns\n        worksheet.columns.forEach((column, index) => {\n            column.width = Math.min(50, Math.max(10, headers[index]?.length || 10));\n        });\n    } else if (data && typeof data === 'object') {\n        const flattened = flattenObject(data);\n        \n        worksheet.addRow(['Key', 'Value']);\n        const headerRow = worksheet.getRow(1);\n        headerRow.font = { bold: true };\n        \n        for (const [key, value] of Object.entries(flattened)) {\n            worksheet.addRow([key, value]);\n        }\n        \n        worksheet.columns = [\n            { width: 30 },\n            { width: 50 }\n        ];\n    }\n    \n    // Return buffer\n    return await workbook.xlsx.writeBuffer();\n}\n\n// Convert data to PDF format (requires pdfkit)\nfunction toPDF(data, title = 'Exported Data') {\n    if (!loadPDFKit()) {\n        throw new Error('PDF export requires pdfkit. Run: npm install pdfkit');\n    }\n    \n    return new Promise((resolve, reject) => {\n        const chunks = [];\n        const doc = new PDFDocument({ margin: 50 });\n        \n        doc.on('data', chunk => chunks.push(chunk));\n        doc.on('end', () => resolve(Buffer.concat(chunks)));\n        doc.on('error', reject);\n        \n        // Title\n        doc.fontSize(20).font('Helvetica-Bold').text(title, { align: 'center' });\n        doc.moveDown(0.5);\n        doc.fontSize(10).font('Helvetica').fillColor('gray')\n           .text(`Generated: ${new Date().toISOString()}`, { align: 'center' });\n        doc.moveDown(1);\n        doc.fillColor('black');\n        \n        if (Array.isArray(data) && data.length > 0) {\n            // Flatten for table display\n            const flattenedRows = data.map(row => flattenObject(row));\n            \n            // Collect all headers\n            const headersSet = new Set();\n            flattenedRows.forEach(row => {\n                Object.keys(row).forEach(key => headersSet.add(key));\n            });\n            const headers = Array.from(headersSet);\n            \n            // Simple table rendering\n            const startX = 50;\n            const colWidth = Math.min(100, (doc.page.width - 100) / headers.length);\n            let y = doc.y;\n            \n            // Header\n            doc.fontSize(9).font('Helvetica-Bold');\n            headers.forEach((h, i) => {\n                doc.text(h.substring(0, 15), startX + (i * colWidth), y, {\n                    width: colWidth - 5,\n                    height: 20,\n                    ellipsis: true\n                });\n            });\n            \n            y += 20;\n            doc.moveTo(startX, y).lineTo(startX + (headers.length * colWidth), y).stroke();\n            y += 5;\n            \n            // Data rows\n            doc.font('Helvetica').fontSize(8);\n            flattenedRows.forEach((row, rowIndex) => {\n                if (y > doc.page.height - 50) {\n                    doc.addPage();\n                    y = 50;\n                }\n                \n                headers.forEach((h, i) => {\n                    const val = String(row[h] ?? '').substring(0, 20);\n                    doc.text(val, startX + (i * colWidth), y, {\n                        width: colWidth - 5,\n                        height: 15,\n                        ellipsis: true\n                    });\n                });\n                y += 15;\n            });\n        } else if (data && typeof data === 'object') {\n            const flattened = flattenObject(data);\n            \n            doc.fontSize(10);\n            for (const [key, value] of Object.entries(flattened)) {\n                doc.font('Helvetica-Bold').text(`${key}: `, { continued: true });\n                doc.font('Helvetica').text(String(value));\n            }\n        } else {\n            doc.text('No data available');\n        }\n        \n        doc.end();\n    });\n}\n\n// Convert data to HL7 v2.x pipe-delimited format\nfunction toHL7v2(data) {\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);\n    const messageId = generateUID() + generateUID(); // 16 char message control ID\n    \n    // HL7 v2.x delimiters\n    const fieldSep = '|';\n    const compSep = '^';\n    const repSep = '~';\n    const escChar = '\\\\';\n    const subCompSep = '&';\n    \n    // Escape HL7 special characters\n    const escapeHL7 = (str) => {\n        if (str === null || str === undefined) return '';\n        return String(str)\n            .replace(/\\\\/g, '\\\\E\\\\')\n            .replace(/\\|/g, '\\\\F\\\\')\n            .replace(/\\^/g, '\\\\S\\\\')\n            .replace(/&/g, '\\\\T\\\\')\n            .replace(/~/g, '\\\\R\\\\')\n            .replace(/\\r/g, '')\n            .replace(/\\n/g, '\\\\X0A\\\\');\n    };\n    \n    let segments = [];\n    \n    // MSH - Message Header\n    segments.push([\n        'MSH',\n        '^~\\\\&',                    // Encoding characters\n        'XYOPS',                    // Sending Application\n        'XYOPS_FACILITY',           // Sending Facility  \n        'RECEIVING_APP',            // Receiving Application\n        'RECEIVING_FACILITY',       // Receiving Facility\n        timestamp,                  // Date/Time of Message\n        '',                         // Security\n        'ORU^R01^ORU_R01',         // Message Type (Observation Result)\n        messageId,                  // Message Control ID\n        'P',                        // Processing ID (P=Production)\n        '2.5.1'                     // Version ID\n    ].join(fieldSep));\n    \n    // PID - Patient Identification (generic placeholder)\n    segments.push([\n        'PID',\n        '1',                        // Set ID\n        '',                         // Patient ID (External)\n        'XYOPS_DATA^^^XYOPS',      // Patient ID (Internal)\n        '',                         // Alternate Patient ID\n        'Export^Data^File',         // Patient Name\n        '',                         // Mother's Maiden Name\n        '',                         // Date of Birth\n        '',                         // Sex\n        '',                         // Patient Alias\n        '',                         // Race\n        '',                         // Address\n        '',                         // County Code\n        '',                         // Phone - Home\n        '',                         // Phone - Business\n        '',                         // Primary Language\n        '',                         // Marital Status\n        '',                         // Religion\n        '',                         // Patient Account Number\n        ''                          // SSN\n    ].join(fieldSep));\n    \n    // OBR - Observation Request\n    segments.push([\n        'OBR',\n        '1',                        // Set ID\n        messageId,                  // Placer Order Number\n        messageId,                  // Filler Order Number\n        'EXPORT^Data Export^XYOPS', // Universal Service ID\n        '',                         // Priority\n        timestamp,                  // Requested Date/Time\n        timestamp                   // Observation Date/Time\n    ].join(fieldSep));\n    \n    // Convert data to OBX segments\n    let obxSetId = 0;\n    \n    const addOBX = (key, value, valueType = 'ST') => {\n        obxSetId++;\n        // Determine value type based on content\n        let vt = valueType;\n        let val = escapeHL7(value);\n        \n        if (typeof value === 'number') {\n            vt = Number.isInteger(value) ? 'NM' : 'NM';\n            val = String(value);\n        } else if (typeof value === 'boolean') {\n            vt = 'ST';\n            val = value ? 'true' : 'false';\n        }\n        \n        segments.push([\n            'OBX',\n            String(obxSetId),           // Set ID\n            vt,                         // Value Type (ST=String, NM=Numeric)\n            `${escapeHL7(key)}^^XYOPS`, // Observation Identifier\n            '1',                        // Observation Sub-ID\n            val,                        // Observation Value\n            '',                         // Units\n            '',                         // Reference Range\n            '',                         // Abnormal Flags\n            '',                         // Probability\n            '',                         // Nature of Abnormal Test\n            'F',                        // Observation Result Status (F=Final)\n            '',                         // Effective Date\n            '',                         // User Defined Access Checks\n            timestamp                   // Date/Time of Observation\n        ].join(fieldSep));\n    };\n    \n    // Process data\n    if (Array.isArray(data)) {\n        data.forEach((item, rowIndex) => {\n            // Add a NTE (Notes) segment to separate rows\n            if (rowIndex > 0) {\n                segments.push(`NTE|${rowIndex}||--- Row ${rowIndex + 1} ---`);\n            }\n            \n            if (typeof item === 'object' && item !== null) {\n                const flattened = flattenObject(item);\n                for (const [key, value] of Object.entries(flattened)) {\n                    addOBX(`ROW${rowIndex + 1}_${key}`, value);\n                }\n            } else {\n                addOBX(`ROW${rowIndex + 1}`, item);\n            }\n        });\n    } else if (typeof data === 'object' && data !== null) {\n        const flattened = flattenObject(data);\n        for (const [key, value] of Object.entries(flattened)) {\n            addOBX(key, value);\n        }\n    }\n    \n    // Join segments with carriage return (HL7 standard)\n    return segments.join('\\r\\n');\n}\n\n// Convert data to HL7 FHIR JSON format\nfunction toFHIR(data) {\n    const timestamp = new Date().toISOString();\n    const bundleId = generateUID() + '-' + generateUID();\n    \n    // Create FHIR Bundle\n    const bundle = {\n        resourceType: 'Bundle',\n        id: bundleId,\n        type: 'collection',\n        timestamp: timestamp,\n        entry: []\n    };\n    \n    // Helper to create Observation resource\n    const createObservation = (key, value, index) => {\n        const obsId = `obs-${generateUID()}`;\n        \n        let valueField = {};\n        if (typeof value === 'number') {\n            valueField = {\n                valueQuantity: {\n                    value: value,\n                    unit: 'unit',\n                    system: 'http://unitsofmeasure.org'\n                }\n            };\n        } else if (typeof value === 'boolean') {\n            valueField = { valueBoolean: value };\n        } else {\n            valueField = { valueString: String(value ?? '') };\n        }\n        \n        return {\n            fullUrl: `urn:uuid:${obsId}`,\n            resource: {\n                resourceType: 'Observation',\n                id: obsId,\n                status: 'final',\n                code: {\n                    coding: [{\n                        system: 'http://xyops.local/observations',\n                        code: key.replace(/[^a-zA-Z0-9_-]/g, '_'),\n                        display: key\n                    }],\n                    text: key\n                },\n                effectiveDateTime: timestamp,\n                issued: timestamp,\n                ...valueField\n            }\n        };\n    };\n    \n    // Process data\n    if (Array.isArray(data)) {\n        data.forEach((item, rowIndex) => {\n            if (typeof item === 'object' && item !== null) {\n                // Create a grouped observation or individual observations\n                const flattened = flattenObject(item);\n                for (const [key, value] of Object.entries(flattened)) {\n                    bundle.entry.push(createObservation(`row${rowIndex + 1}_${key}`, value, rowIndex));\n                }\n            } else {\n                bundle.entry.push(createObservation(`row${rowIndex + 1}`, item, rowIndex));\n            }\n        });\n    } else if (typeof data === 'object' && data !== null) {\n        const flattened = flattenObject(data);\n        let index = 0;\n        for (const [key, value] of Object.entries(flattened)) {\n            bundle.entry.push(createObservation(key, value, index++));\n        }\n    }\n    \n    bundle.total = bundle.entry.length;\n    \n    return JSON.stringify(bundle, null, 2);\n}\n\n// Convert data to Markdown format\nfunction toMarkdown(data, title = 'Exported Data') {\n    const escapeMarkdown = (str) => {\n        if (str === null || str === undefined) return '';\n        return String(str)\n            .replace(/\\|/g, '\\\\|')\n            .replace(/\\n/g, '<br>');\n    };\n    \n    let md = `# ${title}\\n\\n`;\n    md += `*Generated: ${new Date().toISOString()}*\\n\\n`;\n    \n    // Handle raw stdout output\n    if (data && typeof data === 'object' && !Array.isArray(data) &&\n        Object.keys(data).length === 1 && data.output && typeof data.output === 'string') {\n        md += '## Output\\n\\n';\n        md += '```\\n' + data.output + '\\n```\\n';\n        return md;\n    }\n    \n    if (Array.isArray(data) && data.length > 0) {\n        // Flatten for table display\n        const flattenedRows = data.map(row => flattenObject(row));\n        \n        // Collect all headers\n        const headersSet = new Set();\n        flattenedRows.forEach(row => {\n            Object.keys(row).forEach(key => headersSet.add(key));\n        });\n        const headers = Array.from(headersSet);\n        \n        // Create markdown table\n        md += '## Data Table\\n\\n';\n        md += '| ' + headers.map(h => escapeMarkdown(h)).join(' | ') + ' |\\n';\n        md += '| ' + headers.map(() => '---').join(' | ') + ' |\\n';\n        \n        flattenedRows.forEach(row => {\n            const values = headers.map(h => escapeMarkdown(row[h] ?? ''));\n            md += '| ' + values.join(' | ') + ' |\\n';\n        });\n    } else if (data && typeof data === 'object') {\n        // Single object - display as definition list\n        const flattened = flattenObject(data);\n        \n        md += '## Data\\n\\n';\n        md += '| Key | Value |\\n';\n        md += '| --- | --- |\\n';\n        for (const [key, value] of Object.entries(flattened)) {\n            md += `| ${escapeMarkdown(key)} | ${escapeMarkdown(value)} |\\n`;\n        }\n    } else {\n        md += '*No data available*\\n';\n    }\n    \n    return md;\n}\n\n// Output success message to xyOps\nfunction outputSuccess(message, filePath) {\n    const result = {\n        xy: 1,\n        code: 0,\n        description: message,\n        files: [filePath]\n    };\n    process.stdout.write(JSON.stringify(result) + '\\n');\n}\n\n// Output error message to xyOps\nfunction outputError(code, message) {\n    const result = {\n        xy: 1,\n        code: code,\n        description: message\n    };\n    process.stdout.write(JSON.stringify(result) + '\\n');\n}\n\n// Ensure directory exists (cross-platform)\nfunction ensureDirectoryExists(dirPath) {\n    if (!fs.existsSync(dirPath)) {\n        fs.mkdirSync(dirPath, { recursive: true });\n    }\n}\n\n// Main execution\nasync function main() {\n    try {\n        // Read input from STDIN\n        const input = await readStdin();\n        \n        // Extract parameters\n        const params = input.params || {};\n        const outputFormat = (params.outputformat || 'json').toLowerCase();\n        const baseFilename = params.filename || 'export';\n        // Normalize path - remove trailing slash(es)\n        let fileLocation = params.filelocation || input.cwd || process.cwd();\n        fileLocation = fileLocation.replace(/\\/+$/, '');\n        const addTimestamp = params.addtimestamp !== false;\n        const addUID = params.adduid === true;\n        const reportTitle = params.reporttitle || baseFilename;\n        const createFolder = params.createfolder !== false;\n        const folderCleanup = params.foldercleanup || 'keep';\n        \n        // Get input data from job (from previous job in chain)\n        // Try multiple possible locations based on xyOps data structure\n        let data = null;\n        let dataSource = 'none';\n        \n        // Helper to check if object has content\n        const hasContent = (obj) => {\n            if (!obj) return false;\n            if (typeof obj === 'string') return obj.trim().length > 0;\n            if (typeof obj === 'object') return Object.keys(obj).length > 0;\n            return true;\n        };\n        \n        // Try various locations where data might be (in order of preference)\n        // 1. job.data - where Shell Plugin puts parsed JSON data (when \"Interpret JSON\" is enabled)\n        if (hasContent(input.job?.data)) {\n            data = input.job.data;\n            dataSource = 'job.data';\n        }\n        // 2. Structured data from job output (if job outputs JSON with data property)\n        else if (hasContent(input.job?.output?.data)) {\n            data = input.job.output.data;\n            dataSource = 'job.output.data';\n        }\n        // 3. Structured data passed as input to the job\n        else if (hasContent(input.job?.input?.data)) {\n            data = input.job.input.data;\n            dataSource = 'job.input.data';\n        }\n        // 4. Raw stdout from the job (common for shell scripts without JSON parsing)\n        else if (hasContent(input.job?.output)) {\n            // job.output is raw stdout string - wrap it for export\n            data = { output: input.job.output };\n            dataSource = 'job.output (raw stdout)';\n        }\n        // 4. Other possible locations\n        else if (hasContent(input.output?.data)) {\n            data = input.output.data;\n            dataSource = 'output.data';\n        }\n        else if (hasContent(input.input?.data)) {\n            data = input.input.data;\n            dataSource = 'input.data';\n        }\n        else if (hasContent(input.data)) {\n            data = input.data;\n            dataSource = 'data';\n        }\n        \n        // Log data source for troubleshooting\n        console.error(`File Export: Using data from '${dataSource}'`);\n        console.error(`File Export: Output format: '${outputFormat}'`);\n        \n        if (!data) {\n            outputError(1, 'No input data found. The previous job did not output any data.');\n            return;\n        }\n        \n        // Build filename\n        let filename = baseFilename;\n        \n        if (addTimestamp) {\n            filename += '_' + generateTimestamp();\n        }\n        \n        if (addUID) {\n            filename += '_' + generateUID();\n        }\n        \n        // Add extension based on format\n        const extensions = {\n            'json': '.json',\n            'csv': '.csv',\n            'html': '.html',\n            'xml': '.xml',\n            'md': '.md',\n            'yaml': '.yaml',\n            'txt': '.txt',\n            'xlsx': '.xlsx',\n            'pdf': '.pdf',\n            'hl7v2': '.hl7',\n            'fhir': '.fhir.json'\n        };\n        const extension = extensions[outputFormat] || '.json';\n        filename += extension;\n        \n        // Check/create output directory\n        if (!fs.existsSync(fileLocation)) {\n            if (createFolder) {\n                console.error(`File Export: Creating folder ${fileLocation}`);\n                ensureDirectoryExists(fileLocation);\n            } else {\n                outputError(1, `Output folder does not exist: ${fileLocation}`);\n                return;\n            }\n        }\n        \n        // Handle folder cleanup options\n        if (folderCleanup === 'delete') {\n            console.error(`File Export: WARNING - Deleting all files in ${fileLocation}`);\n            try {\n                const files = fs.readdirSync(fileLocation);\n                for (const file of files) {\n                    const filePath = path.join(fileLocation, file);\n                    const stat = fs.statSync(filePath);\n                    if (stat.isFile()) {\n                        fs.unlinkSync(filePath);\n                        console.error(`File Export: Deleted ${file}`);\n                    }\n                }\n            } catch (cleanupError) {\n                console.error(`File Export: Cleanup error: ${cleanupError.message}`);\n            }\n        } else if (folderCleanup === 'archive') {\n            const oldFolder = path.join(fileLocation, 'OLD');\n            try {\n                const files = fs.readdirSync(fileLocation);\n                const filesToMove = files.filter(f => {\n                    const fp = path.join(fileLocation, f);\n                    return fs.statSync(fp).isFile();\n                });\n                \n                if (filesToMove.length > 0) {\n                    // Create OLD folder if needed\n                    if (!fs.existsSync(oldFolder)) {\n                        fs.mkdirSync(oldFolder, { recursive: true });\n                        console.error(`File Export: Created archive folder ${oldFolder}`);\n                    }\n                    \n                    // Move files to OLD folder\n                    for (const file of filesToMove) {\n                        const srcPath = path.join(fileLocation, file);\n                        const destPath = path.join(oldFolder, file);\n                        \n                        // If file exists in OLD, add timestamp to avoid overwrite\n                        let finalDest = destPath;\n                        if (fs.existsSync(destPath)) {\n                            const ext = path.extname(file);\n                            const base = path.basename(file, ext);\n                            const ts = Date.now();\n                            finalDest = path.join(oldFolder, `${base}_${ts}${ext}`);\n                        }\n                        \n                        fs.renameSync(srcPath, finalDest);\n                        console.error(`File Export: Archived ${file} to OLD/`);\n                    }\n                }\n            } catch (archiveError) {\n                console.error(`File Export: Archive error: ${archiveError.message}`);\n            }\n        }\n        \n        // Build full file path\n        const filePath = path.join(fileLocation, filename);\n        \n        // Convert data to requested format\n        let content;\n        try {\n            console.error(`File Export: Converting to ${outputFormat}...`);\n            switch (outputFormat) {\n                case 'csv':\n                    content = toCSV(data);\n                    break;\n                case 'html':\n                    content = toHTML(data, reportTitle);\n                    break;\n                case 'xml':\n                    content = toXML(data);\n                    break;\n                case 'md':\n                    content = toMarkdown(data, reportTitle);\n                    break;\n                case 'yaml':\n                    content = toYAML(data);\n                    break;\n                case 'txt':\n                    content = toTXT(data, reportTitle);\n                    break;\n                case 'xlsx':\n                    content = await toExcel(data, reportTitle);\n                    break;\n                case 'pdf':\n                    content = await toPDF(data, reportTitle);\n                    break;\n                case 'hl7v2':\n                    content = toHL7v2(data);\n                    break;\n                case 'fhir':\n                    content = toFHIR(data);\n                    break;\n                case 'json':\n                default:\n                    content = toJSON(data);\n                    break;\n            }\n            console.error(`File Export: Conversion successful, content length: ${content?.length || 0}`);\n        } catch (convError) {\n            console.error(`File Export: Conversion error: ${convError.message}`);\n            outputError(500, `Conversion to ${outputFormat} failed: ${convError.message}`);\n            return;\n        }\n        \n        // Write file (handle binary formats like xlsx and pdf)\n        console.error(`File Export: Writing to ${filePath}`);\n        try {\n            if (Buffer.isBuffer(content)) {\n                fs.writeFileSync(filePath, content);\n            } else {\n                fs.writeFileSync(filePath, content, 'utf8');\n            }\n            console.error(`File Export: File written successfully`);\n        } catch (writeError) {\n            console.error(`File Export: Write error: ${writeError.message}`);\n            outputError(500, `Failed to write file: ${writeError.message}`);\n            return;\n        }\n        \n        // Output success with file for xyOps to upload\n        outputSuccess(`Successfully exported data to ${filename}`, filePath);\n        \n    } catch (error) {\n        outputError(500, `Export failed: ${error.message}`);\n    }\n}\n\n// Run the plugin\nmain();",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "filename",
						"title": "Filename",
						"type": "text",
						"caption": "Base filename without extension (extension is added automatically based on output format).",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": true
					},
					{
						"id": "outputformat",
						"title": "Output format",
						"type": "select",
						"caption": "Select the file format for the exported data.",
						"locked": false,
						"value": "JSON [json], CSV [csv], HTML [html], XML [xml], Markdown [md], YAML [yaml], Plain Text [txt], Excel [xlsx], PDF [pdf], HL7 v2.x [hl7v2], HL7 FHIR [fhir]"
					},
					{
						"id": "filelocation",
						"title": "File location",
						"type": "text",
						"caption": "Directory path where the file will be saved. Leave empty to use the job's temp directory.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "createfolder",
						"title": "Create folder",
						"type": "checkbox",
						"caption": "Automatically create the output folder if it does not exist. If disabled, an error is thrown when the folder is missing.",
						"locked": false,
						"value": false
					},
					{
						"id": "addtimestamp",
						"title": "Add timestamp",
						"type": "checkbox",
						"caption": "Append a timestamp (YYYYMMDD_HHmmss) to the filename.",
						"locked": false,
						"value": false
					},
					{
						"id": "adduid",
						"title": "Add short UID",
						"type": "checkbox",
						"caption": "Append an 8-character unique identifier to the filename.",
						"locked": false,
						"value": false
					},
					{
						"id": "foldercleanup",
						"title": "Folder kleenup",
						"type": "select",
						"caption": "WARNING: 'DELETE' will permanently remove ALL files in the output folder before export! Use with extreme caution.",
						"locked": false,
						"value": "Keep existing files [keep], Move to OLD subfolder [archive], ⚠️ DELETE all files (DANGEROUS!) [delete]"
					},
					{
						"id": "reporttitle",
						"title": "Report title",
						"type": "text",
						"caption": "Custom title for HTML and Markdown reports. Leave empty to use the filename.",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					}
				],
				"notes": "",
				"icon": "",
				"uid": "",
				"gid": ""
			}
		}
	]
}
